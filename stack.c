#include "stack.h"  // Заголовочный файл, содержащий описание структуры стека и узлов, а также прототипы функций
#include <stdlib.h> // Для работы с динамической памятью (malloc, free)
#include <stdio.h>  // Для вывода сообщений об ошибках (perror)

// Функция для инициализации стека
void initStack(Stack *stack)
{
    stack->top = NULL; // Устанавливаем вершину стека как NULL (пустой стек)
    stack->size = 0;   // Устанавливаем размер стека равным 0
}

// Функция для добавления элемента в стек
void push(Stack *stack, Publication item)
{
    // Выделяем память для нового узла
    Node *newNode = (Node *)malloc(sizeof(Node));
    if (!newNode) // Проверяем, успешно ли выделена память
    {
        perror("Ошибка выделения памяти"); // Выводим сообщение об ошибке
        exit(EXIT_FAILURE);                // Завершаем программу с кодом ошибки
    }

    newNode->data = item;       // Заполняем данные узла
    newNode->next = stack->top; // Указываем, что следующий узел — это текущая вершина стека
    stack->top = newNode;       // Устанавливаем новую вершину стека
    stack->size++;              // Увеличиваем размер стека
}

// Функция для удаления элемента из стека
Publication pop(Stack *stack)
{
    if (stack->size == 0) // Если стек пуст, невозможно удалить элемент
    {
        perror("Попытка удалить элемент из пустого стека"); // Выводим сообщение об ошибке
        exit(EXIT_FAILURE);                                 // Завершаем программу с кодом ошибки
    }

    Node *temp = stack->top;       // Сохраняем указатель на текущую вершину
    Publication item = temp->data; // Сохраняем данные вершины
    stack->top = temp->next;       // Перемещаем вершину на следующий узел
    free(temp);                    // Освобождаем память, занятую удаляемым узлом
    stack->size--;                 // Уменьшаем размер стека
    return item;                   // Возвращаем данные удалённого элемента
}

// Функция для получения верхнего элемента стека без его удаления
Publication *peek(Stack *stack)
{
    if (stack->size == 0) // Если стек пуст, невозможно посмотреть элемент
    {
        perror("Попытка посмотреть элемент в пустом стеке"); // Выводим сообщение об ошибке
        exit(EXIT_FAILURE);                                  // Завершаем программу с кодом ошибки
    }
    return &stack->top->data; // Возвращаем указатель на данные верхнего элемента
}

// Функция для получения текущего размера стека
int getSize(Stack *stack)
{
    return stack->size; // Возвращаем количество элементов в стеке
}

// Функция для получения элемента по индексу
Publication *getElement(Stack *stack, int index)
{
    // Проверяем, что индекс находится в пределах допустимого диапазона
    if (index < 0 || index >= stack->size)
    {
        return NULL; // Если индекс некорректен, возвращаем NULL
    }

    Node *current = stack->top;     // Начинаем с вершины стека
    for (int i = 0; i < index; i++) // Проходим по элементам до указанного индекса
    {
        current = current->next;
    }
    return &current->data; // Возвращаем указатель на данные элемента
}

// Функция для очистки стека (удаления всех элементов)
void clearStack(Stack *stack)
{
    while (stack->size > 0) // Пока в стеке есть элементы
    {
        pop(stack); // Удаляем элемент с вершины
    }
}